# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Сысоев М.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В императивных языках данные можно хранить и как в языке Пролог, однако наоборот, например, использовать массивы с индексацией и доступом к любому элементу уже не получится.

Из cхожих особенностей списки в прологе, на мой взгляд, очень напоминают односвязные списки из императивных языков: текущий элемент (голова) + ссылка на следующий (хвост). Однако, по крайней мере в SWI-Prolog списки может содержать элементы разных типов, что в этом случае делает его более похожим конкретно на списки из Python или кортежи из C++.

## Задание 1.1: Предикат обработки списка

`cutlist(List,N,Reslist), cutlist2(List,N,Reslist) ` - усечение списка до указанной длины

Примеры использования:
```prolog
?- cutlist([1,2,3], 2, T).
T = [1, 2] ;
false.
?- cutlist2([1,10,20,13,0,15], 3, R).
R = [1, 10, 20].
```

Реализация:
```prolog
% Без стандартных предикатов 
cutlist(X,0,[]).
cutlist([X|Y],K,[X|Y1]):-
    K1 is K - 1,
    cutlist(Y,K1,Y1).
% Со стандартными предикатами
cutlist2(Zs, N, Xs) :-
    length(Xs, N),
    append(Xs, _Ys, Zs).
```

`cutlist(List,N,Reslist)` - с помощью декремента отсчитываем кол-во элементов и, когда счётчик дойдёт до нуля - возвращаем пустой список. Произойдёт отсечение (len - N) элементов

`cutlist2(List,N,Reslist)` - копируем первые N элементов в новый список при помощи встроенного метода append

## Задание 1.2: Предикат обработки числового списка

`max_list(List,Max,Index), max_list1(List,Max,Index) ` - вычисление позиции максимального элемента в списке

Примеры использования:
```prolog
?- max_list([1,2,6,10,3,9], Max, Index).
Max = 10,
Index = 3 ;
false.
?- max_list1([1,2,15,10,3,9], Index).
Index = 2 ;
false.
```

Реализация:
```prolog
% Без стандратных предикатов
max_list([X|Xs], Max, Index):-
    max_list(Xs, X, 0, 0, Max,Index).
max_list([], OldMax, OldIndex, _, OldMax, OldIndex).
max_list([X|Xs], OldMax, _, CurrentIndex, Max, Index):-
    X > OldMax,
    NewCurrentIndex is CurrentIndex + 1,
    NewIndex is NewCurrentIndex,
    max_list(Xs, X, NewIndex, NewCurrentIndex, Max, Index).
max_list([X|Xs], OldMax, OldIndex, CurrentIndex, Max, Index):-
    X =< OldMax,
    NewCurrentIndex is CurrentIndex + 1,
    max_list(Xs, OldMax, OldIndex, NewCurrentIndex, Max, Index).
    
%со стандартными предикатами 
comparator([H|T], N):-
	N >= H,
	comparator(T, N).
comparator([], _).
max2(X, N):-
	remove1(N, X, Y),
	comparator(Y, N).
memberwithCounter([X|_], X, 0).
memberwithCounter([_|Y], X, Index):-
	memberwithCounter(Y, X, Index1),
        Index is Index1 + 1.
max_list1(List, Index):-
    max2(List, N),
    memberwithCounter(List, N, Index).
```

`max_list(List, Max, Index)` - запоминаем прошлое максимальное число, его индекс, текущий индекс, текущее максимальное число и его индекс. Сравниваем текущий элемент с элементами в хвосте

`max_list1(List, Index)` - ищем максимальное число в списке, а затем находим его индекс в списке. `max2` - удаляем по одному элементу из списка, проверяем при помощи `comporator`, не меньше ли он какого-либо элемента из оставшегося списка.

## Задание 2: Реляционное представление данных

Для себя из преимуществ реляционного представления смог выделить то, что эта модель сама по себе достаточно простая, легкая для понимания человеком. Из недостатков - могут появится трудности при разработке в достаточно простых местах.

Достоинство, конкретно моего, представления состоит в лёгкости доступа к данным, например, оценкам конкретных студентов.

```prolog
sub_average_mark(Subject, N):-
    subject(Sub, Subject),
    findall(Mark, grade(_, Sub, Mark), Marks),
    get_summ(Marks, S),
    length(Marks, X),
    N is S / X.
```
Пример работы:
```prolog
?- sub_average_mark('Logic Programming', X).
X = 3.9642857142857144.
?- sub_average_mark('English language', X).
X = 4.178571428571429.
```

Предикат средней оценки за предмет, где Subject - предмет, N - оценка. Ищет "тег" предмета по его полному названию, далее составляет список всех оценок по конкретному предмету с помощью findall, подсчитывает сумму с помощью вспомогательного предиката get_summ, считает длину списка всех оценок и делит сумму на их количество.
Вспомогательный предикат get_summ:
```prolog
get_summ([], 0).
get_summ([X|T], Mark):-
    get_summ(T, Mark1), Mark is Mark1 + X.
```

```prolog
failed(Group, N):-
    findall(Stud, (student(Group, Stud), grade(Stud, _, 2)), List),
    length(List, N).
```
Предикат поиска количества студентов из конкретной группы, не сдавших экзамены (получили оценку 2), где Group - номер группы, N - количество студентов. С помощью findall создаётся список тех студентов, которые принадлежат данной группе и получили 2 за какой-либо экзамен, подсчитывается длина списка.

Пример работы:
```prolog
?- failed(102,N).
N = 7.
```


```prolog
failed_subject(Subject, N):-
    subject(Sub, Subject),
    findall(Stud, grade(Stud, Sub, 2), Failed_subj),
    length(Failed_subj, N).
```
Предикат поиска количества студентов, не сдавших конкретный предмет, где Subject - предмет, N - количество студентов.
Предикат ищет "тег" предмета по его полному названию, составляет список всех студентов, не сдавших конкретный предмет и подсчитывает длину списка.

Пример работы:
```prolog
?- failed_subject('Logic Programming', X).
X = 3.
?- failed_subject('Mathematical Analys', X).
X = 6.
```

## Выводы

Складывается ощущение, что решать повседневные задачи на prolog - не самая лучшая затея - уходит много времени и сил, в особенности на такие задания, как второе. На мой взгляд, prolog отлично подходит для решения логических задач и задач, связанных с множествами, в которых много различных условий. Остальные же задания, как, к примеру, второе, связанные с парсингом текста и обработкой каких-либо данных, зачастую проще решаются при помощи императивных языков программирования.

Если говорить про саму лабораторную работу, то сначала встетил проблемы с восприятием prolog, составлением алгоритмов на нём - парадигма мышления отличается от классических императивных языков. В итоге, пока так и не получилось мыслить в рамках только логического программирования: сначала думал, как решить эту задачу на императивном языке программирования, а затем переводил всё это под логику prolog.




