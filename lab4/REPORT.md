# Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Сысоев М.А

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   25.12      |       4       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Каждый анализ естественного языка сводиться к следующим этапам:
 - предварительный анализ (поиск границ слов и предложений)
 - морфологический анализ (установление словарных форм слов и приписывание им морфологических признаков),
 - синтаксический анализ (зависимости между словами)
 - семантический анализ (смысл предложения или отдельных слов). 

Главной задачей анализа естественного языка является выявление закономерностей. В этом используется два подхода -- работа эксперта-лингвиста и автоматическое исследование размеченных данных.

Пролог удобен для таких задач, так как на нём приятно описывать грамматику, она очевидна человеку, который читает код, и программисту, который его пишет.

## Задание

Варинат 6. Реализовать синтаксический анализатор логического выражения и вычислить
его значение. В выражение допустимы операции отрицания, дизъюнкции,
конъюнкции, следования. {~, V, &, =>}. Истинные считаются только термы
заданы фактами вида
true(river_volga).
true(pupil_vasia).
************
`Запрос: ?-calculate(['(',false, 'V', river_volga,')', '&', true], X).
Результат: X=true.`

## Принцип решения


Граматика языка содержит следующие атомы:
- логические операторы`(~, V, &, =>)`
- Переменные`(true, false + любая переменная, определённая в true(X))`
- Скобки`{'(', ')'}`

Запросы следует выполнять в следующем виде:
`calculate([X, 'O1', Y, 'O2', Z]).`, где O - оператор, X,Y,Z - переменные. Также стоит учесть, что кол-во открывающих скобок должно быть равно кол-ву закрывающих.

Суть решения очень проста. Проходимся по списку и выявляем простые формы утвержений. Под формой имеется ввиду шаблон А `{~, V, &, =>}` B, где А и В - простые выражения. Вычисляем ответ на эту форму и подставляем в список для дальнейшего рекурсивного вычисления. Каждый предикат вычисления формы представлен в двух вариантах - для true и false. В первом случае вычисляем условия true(используя понятия таблицы истинности для логической операции) и валидность входных данных. При false проверяем только валидность. 
```prolog
solver([A,'V',B | T], R):-
	(true(A); true(B)),
	check(A),
	check(B),
	solver([true|T],R), !.

solver([A,'V',B | T], R):-
	check(A),
	check(B),
	solver([false|T],R).
```

Рекурсивное вычисление выражения:
```prolog
solver([A|[B|T]],R):-
	solver([B|T],Y),
	[B|T] \= Y,
	solver([A|Y],R),!.
```

## Результаты

```
?- calculate(['(','river_volga','&',true,')','&',true],R).
R = true.
?- calculate([false,'&','(','(','river_volga','&',true,')','&',true,')'],R).
R = false.
?- calculate(['(',false, 'V', 'river_volga',')', '&', true], R).
R = true.
```

## Выводы

Главное преимущество Prolog - перебором просто решаются задачи с искусственным и естественным языком.

Во время работы задумался над вопросом границ применения этой технологии. Возможно ли реалзиовать полноценно весь язык? Пришёл к выводу, что скорее нет, чем да. Язык - штука изменчивая, а потому человек не сможет успевать вносить изменения при проектировании такой системы. Плюс массив данных предстоит обработать колосальный

Пролог был удобен для решения задач грамматического разбора, в виду простой и очевидной реализации правил перехода.





