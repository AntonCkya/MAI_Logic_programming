# Реферат
## по курсу "Логическое программирование"

### студент: Сысоев М.А.

## ТЕМА
### Сравнение реализации алгоритмов поиска на логических и императивных языках


## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

### Введение
Для начала, введём явные понятия логического и императивного программирования:
> **Логическое программирование** — парадигма программирования, основанная на автоматическом доказательстве теорем. Основано на теории и аппарате математической логики с использованием математических принципов резолюций.

> **Императивное программирование** — это парадигма программирования, для которой характерно следующее: </br> 
• В исходном коде программы записываются инструкции </br>
• Инструкции должны выполняться последовательно</br>
• Данные, получаемые при выполнении предыдущих инструкций, могут читаться из памяти последующими инструкциями </br>
• Данные, полученные при выполнении инструкции, могут записываться в память.

Отлично. Как можно заметить, иметь дело придётся с совершенно разными подходами. Почему эта тема в принципе поднимается? Актуально ли это? 

В одно время считалось, что логическое программирование может "захватить" мир и все будут писать только так. Действительно, некоторые типы задач прекрасно решаются на языках логической парадигмы. Это неоспоримый факт, который мы выяснили по ходу курса. Однако, с огромной вероятностью Вашим первым языком был императивный. И когда люди впервые сталкиваются с языком логического программирования, у них возникают трудности в смене парадигм мышления. Потому что программы пишутся по-разному. Задачи решаются по-другому. Поэтому, актуальность в сравнении чего-либо на логическом языке программирования и императивном будет всегда. Как минимум потому, что это интересно. Думаю, у многих возникал вопрос "А кто же круче?". Это я и собираюсь выяснить на примере алгоритмов поиска в графе (в ширину и глубину). 

### Немного формальности

Перед рассуждением, хотелось бы формализовать задачу.
Для начала, что значит "Сравнить"? Какие метрики будем использовать?

#### Временная сложность
Временная сложность - это скорость увеличения числа операций при возрастании размерности задачи. Классический параметр для алгоритмов. Не отходя от классики, будем использовать Big О нотацию.

#### Пространственная сложность
Пространственная сложность - зависимость количества занимаемой памяти от размера входных данных. Аналогично описывается через Big O нотацию. Во многих задачах память также важна, как и скорость, поэтому не учитывать этот параметр нельзя. Тем более в логических языках программирования, где её роль, как мне кажется, возрастает.

#### Особенности 
Здесь выделим тонкости данной конкретной реализации алгоритма. 

#### Субъективная сложность реализации алгоритма
Тут мы ответим на вопросы "Что проще написать?", "Что проще понять?"

Также нужно выбрать языки программирования, на которых будут реализованы алгоритмы. 

*- Леди и джентльмены! В левом углу ринга, 49-ти летний представитель логических языков программирования, неоспоримо самый популярный, красивый и изящный! Встречайте, Prolog!   
В правом углу ринга, 38-ми летний представитель императивных языков программирования, мощный, статически типизированный, быстрый, гибкий, лучший друг олимпиадного программирования - С++!* 

Язык Prolog действительно является самым популярным языком логического программирования. Также, Prolog изучался мною в течение курса, поэтому выбор был очевиден.  

У императивных же языков выбор побогаче - C, C++, Java, Python, Bash - те, на которых умею писать.
Откинув C (C++ удобнее), Java(C++ немнооого короче) и Bash (Сложный синтаксис), шансы осталось лишь у C++ и Python. За второй было то, что он, как и Prolog интерпретируемый, лаконичный и красивый. Однако, когда я вижу слово "алгоритм", в голову сразу же приходит язык С++. Вероятно, сказалось влияние олимпиадного программирования на первом курсе... 
Поэтому, из леса императивных языков я выбираю С++. Оба языка, разумеется, полные по Тьюрингу.

> В реферате будет использован код SWI Prolog version 8.4.0 и C++20.

С формальностями покончено, пора приступать к делу! А начнём мы с...

## Поиск в глубину в графе

Для начала стоит рассмотреть структуру представления графа. Как правило, его задают матрицами смежности/инцидентности. В Prolog же можно использовать встроенную базу данных (или списки). Например:
```prolog
edge(a, b).
edge(b, d).
edge(b, e).
edge(c, e).
edge(d, e).
```
Это представление следующего графа:
<p>
<img src="https://github.com/Maxsmile123/Maxsmile123/blob/0991e42790b1b8068a975650d41bd5ea0bfebf16/res/FxxsBlLyAQyoSbto.png">  
</p>

> Важно отметить, что при таком представлении графа мы не можем описать изолированные вершины. Для их реализации придётся вводить либо факты для всех вершин `node(a)`, либо несуществующий путь из *a* в *a* `edge(a, a)`.

На С++ будем использовать классическую матрицу смежности. Её принцип прост: на `a[i][j]` элементе стоит значение равное количеству рёбер из i-ой вершины в j-ую. Размер матрицы равен NxN, где N - кол-во вершин графа.

## Поиск в глубину на Prolog
```prolog
% Переместиться из X В Y можно, если есть ребро из X в Y или из Y в Х
move(X, Y):- 
    edge(X, Y);
    edge(Y, X).

% Вызываем вспомогательный предикат
dfs(X, Y, P):- path([X], Y, P).

% Предикат продления пути с предотвращением петель
prolong([X|T], [Y, X|T]) :-
    move(X, Y),
    not(member(Y, X|T)).

% Завершение, если мы в целевой вершине
path([X|T], X, [X|T]).
% Иначе продляем путь и продолжаем поиск 
path(P, Y, R) :-
    prolong(P, P1),
    path(P1, Y, R).
```
Если убрать комментарии и символы перевода строки для удобочитаемости, то алгоритм занимает всего 11 строк.

Цель: Мы находимся в вершине X, хотим попасть в вершину Y. 

Идея: В предикате `dfs(X, Y, P)` вызывается `path`, используя первым аргументом список посещённых вершин. Так как мы уже в X, то, его наличие там, надеюсь, вопросов не вызывает. Далее, предикатом `prolong` мы ищем куда можно попасть из X. При этом, если вершину уже посетили, то ребро в неё не рассматривается. После для новых вершин проделываем то же самое, пока не попадём в точку назначения.

Хорошо, а что насчёт характеристик? 

#### Временная сложность
O(b^lmax) = O(1 + b + b^2...b^l), где b - среднее количество разветвлений из вершины, lmax - максимальная длина пути

#### Пространственная сложность
Мы одновременно храним только один путь, поэтому пространственная сложность - О(lmax)

#### Особенности 
У этого алгоритма есть несколько тонкостей.
Во-первых, он не позволяет искать пути с циклами.   
Во-вторых, не всегда находит кратчайшее решение первым. Далеко не всегда. Порядок нахождения путей определён предикатом `move(X, Y)`. Это значительный минус для многих задач.

#### Субъективная сложность реализации алгоритма
На мой взгляд, алгоритм очень приятно записывается на логическом языке. 11 строк и готово. Также возьмём во внимание факт, что в основе логического вывода лежит поиск в глубину. Поэтому, реализовать его на Prolog можно быстро и приятно.

## Поиск в глубину на C++
```C++
void DFS(int v, int from)
{
    if (mark[v] != 0)  // Если мы здесь уже были, то тут больше делать нечего
    {
        return;
    }
    mark[v] = 1;   // Помечаем, что мы здесь были
    prior[v] = from;  // Запоминаем, откуда пришли
    if (v == finish)   // Проверяем, конец ли
    {
        cout << "The path was found!\n";
        return;
    }
    for (int i = 0; i < (int)edges[v].size(); ++i)  // Для каждого ребра
    {
        DFS(edges[v][i], v);  // Запускаемся из соседа
    }
}
```

Для меня стало сюрпризом то, что на С++ вышло также 10-11 строк кода. Однако, стоит признать, что это лишь одна функция. Полноценная программа на С++ включает в себя подключения библиотек, описание функции main, объявление переменных и другое. Вся программа у меня вышла в 54 строки.

Цель: Пометить каждую вершину, как посещённую, избегая циклов, пока не дошли до конечной точки. 

Идея заключается в том, что мы двигаемся от начальной вершины по определенному пути до тех пор, пока не достигнем конца пути или пункта назначения (искомой вершины). Если мы достигли конца пути, но он не является пунктом назначения, то мы возвращаемся назад (к точке разветвления или расхождения путей) и идем по другому маршруту.

На самом деле, на императивных языках больше возможностей для реализации алгоритма. Можно сделать как рекурсивно, так и через стек. В логических языках, которые стоят на понятии рекурсии, такое представить сложновато.

#### Временная сложность
O(V + D), где V - общее число вершин, D - общее число граней.

#### Пространственная сложность
Так как мы используем рекурсию в реализации, то значит используется стек, из чего следует, что пространственная сложность - O(V).

#### Особенности 
Аналогичны реализации на Prolog

#### Субъективная сложность реализации алгоритма
Разновидностей алгоритма на С++ довольно много, благодаря богатой стандартной библиотеке. Разумеется, можно было бы сделать короче, используя, например, стек или как-то ещё оптимизировать. Однако, кажется, с точки зрения обычного человека, не программиста, код на прологе выглядит лучше, понятнее. 

Если подвести какой-то итог, то так как алгоритм, по сути, одинаковый, то сложность как временная, так и пространственная совпадают. Писать алгоритм мне больше понравилось на Prolog - пишете меньше, а получаете всё и сразу. 


## Поиск в ширину в графе

Структура представления графа как в Prolog, так на С++ остаются такими же. 

## Поиск в ширину на Prolog
```prolog
% Переместиться из X В Y можно, если есть ребро из X в Y или из Y в Х
move(X, Y):- 
    edge(X, Y);
    edge(Y, X).

% Вызываем вспомогательный предикат
bfs(X, Y, P):- path([[X]], Y, P).

% продление пути
prolong([X|T], [Y, X|T]) :-
    move(X, Y),
    not(member(Y, X|T)).

% Завершение, если мы в целевой вершине
path([[X|T]|_], X, [X|T]).
path(P, Y, R) :-
    findall(Z, prolong(P, Z), T), % Продление первого пути в очереди всевозможными способами
    append(QI, T, QO), !,
    path(QO, X, R).

path([_|T], Y, L) :- path(T, Y, L). % удаляем из очереди не продляемый путь
```
Если убрать комментарии и символы перевода строки для удобочитаемости, то алгоритм занимает всего 13 строк.

Идея: Используем очередь путей. Если продлить путь из очереди невозможно - удаляем путь. Таким образом получаем поиск в ширину.

Ладно, а что там по характеристикам?

#### Временная сложность
O(b^lmax) = O(1 + b + b^2...b^l), где b - среднее количество разветвлений из вершины, lmax - максимальная длина пути. Такая же, как и у поиска в глубину. В худшем случае придётся обойти весь граф.

#### Пространственная сложность
O(b^l), где b - среднее количество разветвлений из вершины, l - длина пути. Это много, но, если существует короткий путь, то памяти потратиться немного.

#### Особенности 
Пути с циклами уже не являются для нас помехой - алгоритм их найдёт и не зациклиться. Также, стоит отметить, что первым найдётся самый короткий путь! Во многих задачах это довольно важное условие.  

#### Субъективная сложность реализации алгоритма
В целом, очередь путей является не самым очевидным решением. Сама логика алгоритма ясна, но записывается и реализовывается он несколько сложнее поиска в глубину, за счёт усложнения некоторых конструкций и использования отсечения. 

## Поиск в ширину на C++
Предполагается, что start - глобальная переменная, в которой хранится номер начальной вершины.
```C++
void BFS()
{
    queue<int> q;
    // Инициализация: есть информация про начальную вершину
    q.push(start);
    d[start] = 0;
    mark[start] = 1;
    // Главный цикл - пока есть серые вершины
    while (!q.empty())
    {
        // Берем первую из них
        int v = q.front();
        q.pop();
        // Пробегаемся по всем ее соседям
        for (int i = 0; i < (int)edges[v].size(); ++i)
        {
            // Если сосед белый
            if (mark[edges[v][i]] == 0)
            {
                // То вычисляем расстояние
                d[edges[v][i]] = d[v] + 1;
                // И он становится серым
                mark[edges[v][i]] = 1;
                q.push(edges[v][i]);
            }
        }
    }
}
```

Цель: необходимо найти минимальный путь от одной вершины графа до другой.

Идея заключается в том, что вводится некое обозначение вершин. Белая - не рассмотрена, серая - находится на расстоянии от текущей + 1, чёрная - посещена.   
<p>
<img src="https://github.com/Maxsmile123/Maxsmile123/blob/0991e42790b1b8068a975650d41bd5ea0bfebf16/res/58d44c98c62f9c5107bd2da0d1850b9a.gif">  
</p>



#### Временная сложность
Для каждого ребра и каждой вершины выполняется константное число действий, следовательно, временная сложность - O(V + D), где V - общее число вершин, D - общее число граней.

#### Пространственная сложность
Максимальное число вершин, одновременно хранящихся в очереди — V, следовательно, пространственная сложность - O(V).

#### Особенности 
Аналогично реализации на Prolog

#### Субъективная сложность реализации алгоритма
Реализация на С++ не представляется для меня сложной. Используем очередь для хранения вершин, внутри которой и формируется наш кратчайший путь. Алгоритм занимает всего 11 строчек, не использует неявных понятий(Таких, как отсечение) и при этом сразу понятно, что мы используем очередь, а не какую-то другую структуру. В реализации на Prolog это неочевидно - там список списков, который программно имитирует очередь. И да, мы не используем рекурсию, что также приносит плюс в карму алгоритму на С++.

Как итог, реализация на С++ мне нравится больше. Она обладает большей гибкостью, записывается короче и понятнее.

Думаю, этих двух алгоритмов поиска достаточно для сформирования конечного мнения. Можно, конечно, привести в пример поиск, например, в списке, но обе программы будут написаны в 1-3 строчки, иметь одинаковые оценки сложности и особенности. 

## Вывод
По ходу написания эссе возникало ощущение, что я просто переписываю одни и те же мысли разными словами. И это не случайность. Алгоритм есть алгоритм, его идея единственна и одинакова. Реализации, в целом, очень похожи. Однако, на мой взгляд, для решения задач поиска в графе лучше использовать С++. Причины такие же, как и то, почему С++ популярнее Prolog - можно реализовать бОльший функционал, сделать несколько реализаций. Возможностей у С++ больше, как ни крути. Рекурсии на Prolog не избежать.  

Однако, поиск на Prolog довольно коротко и понятно записывается, идеально вписывается в задачи поиска в пространстве состояний.

В повседневной жизни я бы использовал С++, но всегда помнил, что на Prolog программу можно написать быстрее.

## Список использованных источников
- Сошников Д.В. «Парадигма логического программирования» ISBN 5-9502-0205-8
- https://habr.com/ru/post/200252/
- https://habr.com/ru/post/124636/
- https://habr.com/ru/post/504374/
- https://backendinterview.ru/algostruct/graph




