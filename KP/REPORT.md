# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: <Сысоев Максим Алексеевич>

## Результат проверки

Вариант задания:

 - [ ] стандартный, без NLP (на 3)
 - [x] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта, надеюсь научиться решать повседневные задачи на языке Prolog, уметь мыслить исключительно в рамках парадигмы логического программирования.

## Задание

1. Скачать файл родословной европейской знати в формате GEDCOM. Изучить каким образом располагаются данные в нём.   
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: с использованием предикатов `father(отец, потомок)` и `mother(мать, потомок)`.   
3. Реализовать предикат проверки/поиска двоюродного брата.  
4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве   
5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы.   

## Получение родословного дерева

Использовать своё родословное дерево не хочу по личным причинам, поэтому использовал предложенное дерево родословной европейской знати. С помощью языка Python удалось посчитать, что количество людей в нём **33 591**.

## Конвертация родословного дерева

Для конвертации использовал императивный язык программирования Python, так как считаю, что он отлично подходит для парсинга текста в данной задаче и, при этом уже был опыт работы с ним. <br>  
Основные моменты программы:   
1. Считываем из файла GEDCOM строки, содержащие теги:
 - SURN - фамилия;
 - GIVN - имя (GIVN + SURN = полное имя);
 - FAMS - семья его родителей (где он был ребенком);
 - FAMC - семья (или семьи), где он сам был родителем;
 - SEX - пол;
 ```python
    res = []
    gedcomFile = open(sys.argv[1], "r", encoding='utf-8')
    for line in gedcomFile:
        for each in ["SURN", "GIVN", "FAMS", "FAMC", "SEX"]:
            if each in line:
                res.append(line)
    gedcomFile.close()
 ```
 2. Очищаем данные от лишней информации, представляем в удобном виде и переводим имена на английский язык:
 ```python
for i in range(0, len(res)):
        listOfWords = res[i].split(' ') # Разбиваем строку на слова
        del listOfWords[0] # Удаляем число, обозначающее уровень
        res[i] = listOfWords
        for k in range(len(res[i])):
            res[i][k] = res[i][k].replace("\n", "") # Убираем символ перевода строки у слова
            res[i][k] = res[i][k].replace("'", "\\'")  # Добавляем экранированный символ '\' перед d' - иначе это ломает строки в прологе.
            if ',' in res[i][k]:
                res[i][k] = res[i][k].replace(",", "")  # Убираем символ запятой
                for j in range(len(res[i]) - k - 1): # Удаляем всё, что после запятой. Остаётся только полезная информация
                    res[i].pop()
                break

for i in range(len(res)):
        if res[i][0] == "SURN":
            tmp = ""
            for j in range(1, len(res[i+1])):
                tmp = tmp + res[i+1][j] + " " # Собираем всё имя в одну строку
            res[i][1] = tmp + res[i][1] # Имя = имя + фамилия
            res[i][1] = translator(res[i][1]) # Переводим имена на английский язык

k = 0
    for i in range(len(res) - 1, 0, -1): # Удаляем записи с пустыми или неизвестными именами
        if res[i][0] != "SURN":
            k = k + 1
        else:
            if (len(res[i][1]) == 0) or (res[i][1][0] == '?') or (res[i][1][-1] == '?') or (res[i][1][0:2] == "N "):
                while k >= 0:
                    del res[i]
                    k = k - 1
            k = 0

 ```
3. Собираем список семей в формате [номер семьи, [родители], [дети]].
4. Обходим список семей и генерируем строки в формате фактов Prolog:
```python
 for family in families:
        if len(family[2]) == 0:
            continue
        for child in family[2]:
            for parent in family[1]:
                if parent[1] == "M":
                    facts.append("father(\'" + parent[0] + "\', \'" + child[0] + "\').\n")
                else:
                    facts.append("mother(\'" + parent[0] + "\', \'" + child[0] + "\').\n")
```

## Предикат поиска родственника

Двоюродный брат - сын дяди или тёти. Реализовал предикат дяди и тёти. Дядя - брат матери или отца. Тётя - сестра матери или отца.   
**Замечание:** в связи с таким представлением (mother и father) невозможно определить пол человека, если он не родитель. Из-за чего не получится определить двоюродных братьев без детей.   
Все необходимые предикаты находятся в файле `task3.pl`.
```prolog
% Двоюродный брат – сын дяди или тетки
% X двоюродный брат Y
cousin(X, Y):-
	uncle(Z, X),
	father(Z, Y),
	sex(Y,m).

cousin(X, Y):-
	aunt(Z, X),
	mother(Z, Y),
	sex(Y,m).

```

## Определение степени родства

Приведите описание метода решения, важные фрагменты исходного кода, протокол работы.

## Естественно-языковый интерфейс

## Выводы

Сформулируйте *содержательные* выводы по курсовому проекту в целом. Чему он вас научила? 
Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки.
